        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>GitDir class / bot_git Library / BOT Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="../styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="../favicon.ico">
        
        </head>
        <body data-library="bot_git" data-type="GitDir">
        <div class="page">
        <div class="header">
          <a href="../index.html"><div class="logo"></div></a>
          <a href="../index.html">BOT Documentation</a>
         &rsaquo; <a href="../bot_git.html">bot_git</a> &rsaquo; <a href="../bot_git/GitDir.html">GitDir</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
        <h2><strong>GitDir</strong>
          class
        </h2>
        
<button id="show-inherited" class="show-inherited">Hide inherited</button>
<div class="doc">
<pre class="source">
class GitDir {
 static const _workTreeArg = '--work-tree=';
 static const _gitDirArg = '--git-dir=';
 static final RegExp _shaRegExp = new RegExp(r'^[a-f0-9]{40}$');

 final Path _path;
 final Path _gitWorkTree;

 GitDir._raw(this._path, [this._gitWorkTree = null]);

 Path get path =&gt; _path;

 Future&lt;int&gt; getCommitCount([String branchName = 'HEAD']) {
   return runCommand(['rev-list', '--count', branchName])
       .then((ProcessResult pr) {
         return int.parse(pr.stdout);
       });
 }

 /**
  * [rev] should probably be a sha1 to a commit.
  * But GIT lets you do other things.
  * See http://git-scm.com/docs/gitrevisions.html
  */
 Future&lt;Commit&gt; getCommit(String rev) {
   return runCommand(['cat-file', '-p', rev])
       .then((ProcessResult pr) {
         return Commit.parse(pr.stdout);
       });
 }

 Future&lt;Map&lt;String, Commit&gt;&gt; getCommits([String branchName = 'HEAD']) {
   return runCommand(['rev-list', '--format=raw', branchName])
       .then((ProcessResult pr) =&gt; Commit.parseRawRevList(pr.stdout));
 }

 Future&lt;List&lt;String&gt;&gt; getBranchNames() {
   return getBranchReferences()
       .then((list) {
         return list
             .map((br) =&gt; br.branchName)
             .toList();
       });
 }

 Future&lt;BranchReference&gt; getBranchReference(String branchName) {
   return getBranchReferences()
       .then((list) {
         final matches = list.where((b) =&gt; b.branchName == branchName)
             .toList();

         assert(matches.length &lt;= 1);
         if(matches.isEmpty) {
           return null;
         } else {
           return matches.single;
         }
       });
 }

 Future&lt;List&lt;BranchReference&gt;&gt; getBranchReferences() {
   return showRef(heads: true)
       .then((List&lt;CommitReference&gt; refs) {
         return refs.map((cr) =&gt; cr.toBranchReference()).toList();
       });
 }

 /*
  * TODO: Test this! No tags. Many tags. Etc.
  */
 Future&lt;List&lt;Tag&gt;&gt; getTags() {
   return showRef(tags: true)
       .then((List&lt;CommitReference&gt; refs) {

         final futures = refs.map((ref) {
           return runCommand(['cat-file', '-p', ref.sha])
               .then((ProcessResult pr) {
                 return Tag.parseCatFile(pr.stdout);
               });
         });

         return Future.wait(futures);
       });
 }

 Future&lt;List&lt;CommitReference&gt;&gt; showRef({bool heads:false, bool tags:false}) {
   final args = ['show-ref'];

   if(heads) {
     args.add('--heads');
   }

   if(tags) {
     args.add('--tags');
   }

   return runCommand(args, false)
       .then((ProcessResult pr) {
         if(pr.exitCode == 1) {
           // no heads present, return empty collection
           return [];
         }

         // otherwise, it should have worked fine...
         assert(pr.exitCode == 0);

         return CommitReference.fromShowRefOutput(pr.stdout);
       });
 }

 Future&lt;BranchReference&gt; getCurrentBranch() {
   return runCommand(['rev-parse', '--verify', '--symbolic-full-name', 'HEAD'])
       .then((ProcessResult pr) {
         return runCommand(['show-ref', '--verify', pr.stdout.trim()]);
       })
       .then((ProcessResult pr) {
         return CommitReference.fromShowRefOutput(pr.stdout).single.toBranchReference();
       });
 }

 Future&lt;List&lt;TreeEntry&gt;&gt; lsTree(String treeish,
     {bool subTreesOnly: false, String path: null}) {
   assert(treeish != null);
   final args = ['ls-tree'];

   if(subTreesOnly == true) {
     args.add('-d');
   }

   args.add(treeish);

   if(path != null) {
     args.add(path);
   }

   return runCommand(args)
       .then((ProcessResult pr) {
         return TreeEntry.fromLsTreeOutput(pr.stdout);
       });
 }

 /**
  * Returns the SHA for the new commit if one is created. `null` if the branch is not updated.
  */
 Future&lt;String&gt; createOrUpdateBranch(String branchName, String treeSha,
                             String commitMessage) {
   requireArgumentNotNullOrEmpty(branchName, 'branchName');
   requireArgumentValidSha1(treeSha, 'treeSha');

   return getBranchReference(branchName)
       .then((BranchReference targetBranchRef) {
         if(targetBranchRef == null) {
           return commitTree(treeSha, commitMessage);
         } else {
           return _updateBranch(targetBranchRef.sha, treeSha, commitMessage);
         }
       })
       .then((String newCommitSha) {
         if(newCommitSha == null) {
           return null;
         }

         assert(Git.isValidSha(newCommitSha));

         final targetBranchRef = 'refs/heads/$branchName';

         // TODO: if update-ref fails should we leave the new commit dangling?
         // or at least log so the user can go clean up?
         return runCommand(['update-ref', targetBranchRef, newCommitSha])
             .then((ProcessResult pr) =&gt; newCommitSha);
       });
 }

 /**
  * Returns the SHA for the new commit if one is created. `null` if the branch is not updated.
  */
 Future&lt;String&gt; _updateBranch(String targetBranchSha, String treeSha, String commitMessage) {
   return getCommit(targetBranchSha)
       .then((Commit commitObj) {
         if(commitObj.treeSha == treeSha) {
           return null;
         }

         return commitTree(treeSha, commitMessage, parentCommitShas: [targetBranchSha]);
       });
 }

 /**
  * Returns the `SHA1` for the new commit.
  *
  * See [git-commit-tree](http://git-scm.com/docs/git-commit-tree)
  */
 Future&lt;String&gt; commitTree(String treeSha, String commitMessage, {List&lt;String&gt; parentCommitShas}) {
   requireArgumentValidSha1(treeSha, 'treeSha');

   requireArgumentNotNullOrEmpty(commitMessage, 'commitMessage');
   requireArgument(commitMessage.trim() == commitMessage, 'commitMessage', 'Value cannot start or end with whitespace.');

   if(parentCommitShas == null) {
     parentCommitShas = [];
   }

   final args = ['commit-tree', treeSha, '-m', commitMessage];

   for(final parentSha in parentCommitShas) {
     requireArgumentValidSha1(parentSha, 'parentCommitShas');
     args.addAll(['-p', parentSha]);
   }

   return runCommand(args)
       .then((ProcessResult pr) {
         final sha = pr.stdout.trim();
         assert(Git.isValidSha(sha));
         return sha;
       });
 }

 // TODO: should be renamed writeBlob?
 /**
  * Given a list of [paths], write those files to the object store
  * and return a [Map] where the key is the input path and the value is
  * the SHA of the newly written object.
  */
 Future&lt;Map&lt;String, String&gt;&gt; writeObjects(List&lt;String&gt; paths) {
   final args = ['hash-object', '-t', 'blob', '-w', '--no-filters', '--'];
   args.addAll(paths);
   return runCommand(args)
       .then((ProcessResult pr) {
         final val = pr.stdout.trim();
         final shas = val.split(new RegExp(r'\s+'));
         assert(shas.length == paths.length);
         assert(shas.every((sha) =&gt; _shaRegExp.hasMatch(sha)));
         final map = new Map&lt;String, String&gt;();
         for(var i = 0; i &lt; shas.length; i++) {
           map[paths[i]] = shas[i];
         }
         return map;
       });
 }

 Future&lt;ProcessResult&gt; runCommand(Iterable&lt;String&gt; args, [bool throwOnError = true]) {
   requireArgumentNotNull(args, 'args');

   final list = args.toList();

   for(final arg in list) {
     requireArgumentNotNullOrEmpty(arg, 'args');
     requireArgument(!arg.contains(_workTreeArg), 'args', 'Cannot contain $_workTreeArg');
     requireArgument(!arg.contains(_gitDirArg), 'args', 'Cannot contain $_gitDirArg');
   }

   if(_gitWorkTree != null) {
     list.insert(0, '$_workTreeArg${_gitWorkTree.toNativePath()}');
   }

   return Git.runGit(list, throwOnError: throwOnError, processWorkingDir: _processWorkingDir);
 }

 Future&lt;bool&gt; isWorkingTreeClean() {
   return runCommand(['status', '--porcelain'])
       .then((ProcessResult pr) =&gt; pr.stdout.isEmpty);
 }

 // TODO: TEST: someone puts a git dir when populated
 // TODO: TEST: someone puts in no content at all

 /**
  * If the content provided matches the content in the specificed [branchName], then
  * `null` is returned.
  *
  * If no content is added to the directory, an [Error] is thrown.
  */
 Future&lt;Commit&gt; populateBranch(String branchName, PopulateTempDir populator, String commitMessage) {
   // TODO: ponder restricting branch names
   // see http://stackoverflow.com/questions/12093748/how-do-i-check-for-valid-git-branch-names/12093994#12093994

   requireArgumentNotNullOrEmpty(branchName, 'branchName');
   requireArgumentNotNullOrEmpty(commitMessage, 'commitMessage');

   _TempDirs tempDirs;

   return getBranchReference(branchName)
       .then((BranchReference value) {

         if(value == null) {
           return _getTempDirPairForNewBranch(branchName);
         } else {
           return _getTempDirPair(branchName);
         }
       })
       .then((_TempDirs value) {
         tempDirs = value;

         return populator(tempDirs.gitWorkTreeDir);
       })
       .then((_) {

         // make sure there is something in the working three
         return tempDirs.gitDir.runCommand(['ls-files', '--others']);
       })
       .then((ProcessResult pr) {
         if(pr.stdout.isEmpty) {
           throw 'No files were added';
         }
         // add new files to index

         // --verbose is not strictly needed, but nice for debugging
         return tempDirs.gitDir.runCommand(['add', '--all', '--verbose']);
       })
       .then((ProcessResult pr) {
         // now to see if we have any changes here
         return tempDirs.gitDir.runCommand(['status', '--porcelain']);
       })
       .then((ProcessResult pr) {
         if(pr.stdout.isEmpty) {
           // no change in files! we should return a null result
           return null;
         }

         // Time to commit.
         return tempDirs.gitDir.runCommand(['commit', '--verbose', '-m', commitMessage])
             .then((ProcessResult pr) {
               // --verbose is not strictly needed, but nice for debugging
               return tempDirs.gitDir.runCommand(['push', '--verbose', '--progress', path.toNativePath(), branchName]);
             })
             .then((ProcessResult pr) {
               // pr.stderr will have all of the info

               // so we have this wonderful new commit, right?
               // need to crack out the commit and return the value
               return getCommit('refs/heads/$branchName');
             });
       })
       .whenComplete(() {
         if(tempDirs != null) {
           return tempDirs.dispose();
         }
       });
 }

 // if branch does not exist, do simple clone, then checkout
 Future&lt;_TempDirs&gt; _getTempDirPairForNewBranch(String newBranchName) {
   TempDir tempGitHost;
   TempDir tempWorkDir;
   GitDir gd;

   return TempDir.create()
       .then((TempDir value) {
         tempGitHost = value;

         return TempDir.create();
       })
       .then((TempDir value) {
         tempWorkDir = value;

         // time for crazy clone tricks
         final args = ['clone', '--shared', '--no-checkout', '--bare', path.toNativePath(), '.'];

         return Git.runGit(args, processWorkingDir: tempGitHost.path);
     })
     .then((ProcessResult pr) {
       final gitPath = new Path(tempGitHost.path);
       final gitWorkingPath = new Path(tempWorkDir.path);

       // git init
       return new GitDir._raw(gitPath, gitWorkingPath);
     })
     .then((GitDir value) {
       gd = value;
       return gd.runCommand(['checkout', '--orphan', newBranchName]);
     })
     .then((ProcessResult pr) {

       // since we're checked out, need to clear out local content
       return gd.runCommand(['rm', '-r', '-f', '.']);
     })
     .then((ProcessResult pr) {
       return new _TempDirs(gd, tempGitHost, tempWorkDir);
     });
 }

 // if branch exists, then clone to that branch, clear it out
 Future&lt;_TempDirs&gt; _getTempDirPair(String existingBranchName) {
   TempDir tempGitHost;
   TempDir tempWorkDir;
   GitDir gd;

   return TempDir.create()
       .then((TempDir value) {
         tempGitHost = value;

         return TempDir.create();
       })
       .then((TempDir value) {
         tempWorkDir = value;

         // time for crazy clone tricks
         final args = ['clone', '--shared', '--branch', existingBranchName, '--bare', path.toNativePath(), '.'];

         return Git.runGit(args, processWorkingDir: tempGitHost.path);
     })
     .then((ProcessResult pr) {
       final gitPath = new Path(tempGitHost.path);
       final gitWorkingPath = new Path(tempWorkDir.path);

       // git init
       return new GitDir._raw(gitPath, gitWorkingPath);
     })
     .then((GitDir value) {
       gd = value;
       return gd.runCommand(['checkout']);
     })
     .then((ProcessResult pr) {

       // since we're checked out, need to clear out local content
       return gd.runCommand(['rm', '-r', '.']);
     })
     .then((ProcessResult pr) {
       return new _TempDirs(gd, tempGitHost, tempWorkDir);
     });
 }

 String get _processWorkingDir =&gt; _path.toString();

 static Future&lt;bool&gt; isGitDir(String path) {
   final dir = new Directory(path);
   return dir.exists()
       .then((bool exists) {
         if(exists) {
           return _isGitDir(dir);
         } else {
           return false;
         }
       });
 }

 /**
  * [allowContent] if true, doesn't check to see if the directory is empty
  *
  * Will fail if the source is a git directory (either at the root or a sub directory)
  */
 static Future&lt;GitDir&gt; init(Directory source, {bool allowContent: false}) {
   assert(source.existsSync());

   if(allowContent == true) {
     return _init(source);
   }

   // else, verify it's empty
   return IoHelpers.isEmpty(source)
       .then((bool isEmpty) {
         if(!isEmpty) {
           throw 'source Directory is not empty';
         }
         return _init(source);
       });
 }

 static Future&lt;GitDir&gt; fromExisting(String gitDirRoot) {
   final path = new Path(gitDirRoot);

   requireArgument(path.isCanonical, 'gitDirRoot', 'provided dir must be canonical - $gitDirRoot');
   requireArgument(path.isAbsolute, 'gitDirRoot', 'provided dir must be absolute - $gitDirRoot');

   return Git.runGit(['rev-parse', '--git-dir'], processWorkingDir: path.toString())
       .then((ProcessResult pr) {
         if(pr.stdout.trim() == '.git') {
           return new GitDir._raw(path);
         } else {
           throw 'The provided value "$gitDirRoot" is not the root of a git directory';
         }
       });
 }

 static Future&lt;GitDir&gt; _init(Directory source) {
   return _isGitDir(source)
       .then((bool isGitDir) {
         if(isGitDir) {
           throw 'Cannot init a directory that is already a git directory';
         }

         return Git.runGit(['init', source.path]);
       })
       .then((ProcessResult pr) {

         // does a bit more work than strictly nessesary
         // but at least it ensures consistency
         return fromExisting(source.path);
       });
 }

 static Future&lt;bool&gt; _isGitDir(Directory dir) {
   assert(dir.existsSync());

   // using rev-parse because it will fail in many scenarios
   // including if the directory provided is a bare repository
   return Git.runGit(['rev-parse'],
       throwOnError: false, processWorkingDir: dir.path)
       .then((ProcessResult pr) {
         // if exitCode is 0, status worked...which means this is a git dir
         return pr.exitCode == 0;
       });
 }
}
</pre>
</div>
<div>
<h3>Static Methods</h3>
<div class="method"><h4 id="isGitDir">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>&gt; <strong>isGitDir</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> path) <a class="anchor-link" href="#isGitDir"
              title="Permalink to GitDir.isGitDir">#</a></h4>
<div class="doc">
<pre class="source">
static Future&lt;bool&gt; isGitDir(String path) {
 final dir = new Directory(path);
 return dir.exists()
     .then((bool exists) {
       if(exists) {
         return _isGitDir(dir);
       } else {
         return false;
       }
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="init">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/GitDir.html">GitDir</a>&gt; <strong>init</strong>(<a href="http://api.dartlang.org/dart_io/Directory.html">Directory</a> source, {<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> allowContent: false}) <a class="anchor-link" href="#init"
              title="Permalink to GitDir.init">#</a></h4>
<div class="doc">
<p>
<span class="param">allowContent</span> if true, doesn't check to see if the directory is empty</p>
<p>Will fail if the source is a git directory (either at the root or a sub directory)</p>
<pre class="source">
static Future&lt;GitDir&gt; init(Directory source, {bool allowContent: false}) {
 assert(source.existsSync());

 if(allowContent == true) {
   return _init(source);
 }

 // else, verify it's empty
 return IoHelpers.isEmpty(source)
     .then((bool isEmpty) {
       if(!isEmpty) {
         throw 'source Directory is not empty';
       }
       return _init(source);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="fromExisting">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/GitDir.html">GitDir</a>&gt; <strong>fromExisting</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> gitDirRoot) <a class="anchor-link" href="#fromExisting"
              title="Permalink to GitDir.fromExisting">#</a></h4>
<div class="doc">
<pre class="source">
static Future&lt;GitDir&gt; fromExisting(String gitDirRoot) {
 final path = new Path(gitDirRoot);

 requireArgument(path.isCanonical, 'gitDirRoot', 'provided dir must be canonical - $gitDirRoot');
 requireArgument(path.isAbsolute, 'gitDirRoot', 'provided dir must be absolute - $gitDirRoot');

 return Git.runGit(['rev-parse', '--git-dir'], processWorkingDir: path.toString())
     .then((ProcessResult pr) {
       if(pr.stdout.trim() == '.git') {
         return new GitDir._raw(path);
       } else {
         throw 'The provided value "$gitDirRoot" is not the root of a git directory';
       }
     });
}
</pre>
</div>
</div>
</div>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="path">
<button class="show-code">Code</button>
final <a href="http://api.dartlang.org/dart_io/Path.html">Path</a>         <strong>path</strong> <a class="anchor-link"
            href="#path"
            title="Permalink to GitDir.path">#</a>
        </h4>
        <div class="doc">
<pre class="source">
Path get path =&gt; _path;
</pre>
</div>
</div>
</div>
<div>
<h3>Methods</h3>
<div class="method"><h4 id="commitTree">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>commitTree</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> treeSha, <a href="http://api.dartlang.org/dart_core/String.html">String</a> commitMessage, {<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; parentCommitShas}) <a class="anchor-link" href="#commitTree"
              title="Permalink to GitDir.commitTree">#</a></h4>
<div class="doc">
<p>Returns the <code>SHA1</code> for the new commit.</p>
<p>See <a href="http://git-scm.com/docs/git-commit-tree">git-commit-tree</a></p>
<pre class="source">
Future&lt;String&gt; commitTree(String treeSha, String commitMessage, {List&lt;String&gt; parentCommitShas}) {
 requireArgumentValidSha1(treeSha, 'treeSha');

 requireArgumentNotNullOrEmpty(commitMessage, 'commitMessage');
 requireArgument(commitMessage.trim() == commitMessage, 'commitMessage', 'Value cannot start or end with whitespace.');

 if(parentCommitShas == null) {
   parentCommitShas = [];
 }

 final args = ['commit-tree', treeSha, '-m', commitMessage];

 for(final parentSha in parentCommitShas) {
   requireArgumentValidSha1(parentSha, 'parentCommitShas');
   args.addAll(['-p', parentSha]);
 }

 return runCommand(args)
     .then((ProcessResult pr) {
       final sha = pr.stdout.trim();
       assert(Git.isValidSha(sha));
       return sha;
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="createOrUpdateBranch">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>createOrUpdateBranch</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> branchName, <a href="http://api.dartlang.org/dart_core/String.html">String</a> treeSha, <a href="http://api.dartlang.org/dart_core/String.html">String</a> commitMessage) <a class="anchor-link" href="#createOrUpdateBranch"
              title="Permalink to GitDir.createOrUpdateBranch">#</a></h4>
<div class="doc">
<p>Returns the SHA for the new commit if one is created. <code>null</code> if the branch is not updated.</p>
<pre class="source">
Future&lt;String&gt; createOrUpdateBranch(String branchName, String treeSha,
                           String commitMessage) {
 requireArgumentNotNullOrEmpty(branchName, 'branchName');
 requireArgumentValidSha1(treeSha, 'treeSha');

 return getBranchReference(branchName)
     .then((BranchReference targetBranchRef) {
       if(targetBranchRef == null) {
         return commitTree(treeSha, commitMessage);
       } else {
         return _updateBranch(targetBranchRef.sha, treeSha, commitMessage);
       }
     })
     .then((String newCommitSha) {
       if(newCommitSha == null) {
         return null;
       }

       assert(Git.isValidSha(newCommitSha));

       final targetBranchRef = 'refs/heads/$branchName';

       // TODO: if update-ref fails should we leave the new commit dangling?
       // or at least log so the user can go clean up?
       return runCommand(['update-ref', targetBranchRef, newCommitSha])
           .then((ProcessResult pr) =&gt; newCommitSha);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getBranchNames">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt;&gt; <strong>getBranchNames</strong>() <a class="anchor-link" href="#getBranchNames"
              title="Permalink to GitDir.getBranchNames">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;List&lt;String&gt;&gt; getBranchNames() {
 return getBranchReferences()
     .then((list) {
       return list
           .map((br) =&gt; br.branchName)
           .toList();
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getBranchReference">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/BranchReference.html">BranchReference</a>&gt; <strong>getBranchReference</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> branchName) <a class="anchor-link" href="#getBranchReference"
              title="Permalink to GitDir.getBranchReference">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;BranchReference&gt; getBranchReference(String branchName) {
 return getBranchReferences()
     .then((list) {
       final matches = list.where((b) =&gt; b.branchName == branchName)
           .toList();

       assert(matches.length &lt;= 1);
       if(matches.isEmpty) {
         return null;
       } else {
         return matches.single;
       }
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getBranchReferences">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../bot_git/BranchReference.html">BranchReference</a>&gt;&gt; <strong>getBranchReferences</strong>() <a class="anchor-link" href="#getBranchReferences"
              title="Permalink to GitDir.getBranchReferences">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;List&lt;BranchReference&gt;&gt; getBranchReferences() {
 return showRef(heads: true)
     .then((List&lt;CommitReference&gt; refs) {
       return refs.map((cr) =&gt; cr.toBranchReference()).toList();
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getCommit">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/Commit.html">Commit</a>&gt; <strong>getCommit</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> rev) <a class="anchor-link" href="#getCommit"
              title="Permalink to GitDir.getCommit">#</a></h4>
<div class="doc">
<p>
<span class="param">rev</span> should probably be a sha1 to a commit.
But GIT lets you do other things.
See http://git-scm.com/docs/gitrevisions.html</p>
<pre class="source">
Future&lt;Commit&gt; getCommit(String rev) {
 return runCommand(['cat-file', '-p', rev])
     .then((ProcessResult pr) {
       return Commit.parse(pr.stdout);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getCommitCount">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/int.html">int</a>&gt; <strong>getCommitCount</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> branchName = 'HEAD']) <a class="anchor-link" href="#getCommitCount"
              title="Permalink to GitDir.getCommitCount">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;int&gt; getCommitCount([String branchName = 'HEAD']) {
 return runCommand(['rev-list', '--count', branchName])
     .then((ProcessResult pr) {
       return int.parse(pr.stdout);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getCommits">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="../bot_git/Commit.html">Commit</a>&gt;&gt; <strong>getCommits</strong>([<a href="http://api.dartlang.org/dart_core/String.html">String</a> branchName = 'HEAD']) <a class="anchor-link" href="#getCommits"
              title="Permalink to GitDir.getCommits">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;Map&lt;String, Commit&gt;&gt; getCommits([String branchName = 'HEAD']) {
 return runCommand(['rev-list', '--format=raw', branchName])
     .then((ProcessResult pr) =&gt; Commit.parseRawRevList(pr.stdout));
}
</pre>
</div>
</div>
<div class="method"><h4 id="getCurrentBranch">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/BranchReference.html">BranchReference</a>&gt; <strong>getCurrentBranch</strong>() <a class="anchor-link" href="#getCurrentBranch"
              title="Permalink to GitDir.getCurrentBranch">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;BranchReference&gt; getCurrentBranch() {
 return runCommand(['rev-parse', '--verify', '--symbolic-full-name', 'HEAD'])
     .then((ProcessResult pr) {
       return runCommand(['show-ref', '--verify', pr.stdout.trim()]);
     })
     .then((ProcessResult pr) {
       return CommitReference.fromShowRefOutput(pr.stdout).single.toBranchReference();
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="getTags">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../bot_git/Tag.html">Tag</a>&gt;&gt; <strong>getTags</strong>() <a class="anchor-link" href="#getTags"
              title="Permalink to GitDir.getTags">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;List&lt;Tag&gt;&gt; getTags() {
 return showRef(tags: true)
     .then((List&lt;CommitReference&gt; refs) {

       final futures = refs.map((ref) {
         return runCommand(['cat-file', '-p', ref.sha])
             .then((ProcessResult pr) {
               return Tag.parseCatFile(pr.stdout);
             });
       });

       return Future.wait(futures);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="isWorkingTreeClean">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>&gt; <strong>isWorkingTreeClean</strong>() <a class="anchor-link" href="#isWorkingTreeClean"
              title="Permalink to GitDir.isWorkingTreeClean">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;bool&gt; isWorkingTreeClean() {
 return runCommand(['status', '--porcelain'])
     .then((ProcessResult pr) =&gt; pr.stdout.isEmpty);
}
</pre>
</div>
</div>
<div class="method"><h4 id="lsTree">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../bot_git/TreeEntry.html">TreeEntry</a>&gt;&gt; <strong>lsTree</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> treeish, {<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> subTreesOnly: false, <a href="http://api.dartlang.org/dart_core/String.html">String</a> path: null}) <a class="anchor-link" href="#lsTree"
              title="Permalink to GitDir.lsTree">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;List&lt;TreeEntry&gt;&gt; lsTree(String treeish,
   {bool subTreesOnly: false, String path: null}) {
 assert(treeish != null);
 final args = ['ls-tree'];

 if(subTreesOnly == true) {
   args.add('-d');
 }

 args.add(treeish);

 if(path != null) {
   args.add(path);
 }

 return runCommand(args)
     .then((ProcessResult pr) {
       return TreeEntry.fromLsTreeOutput(pr.stdout);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="populateBranch">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="../bot_git/Commit.html">Commit</a>&gt; <strong>populateBranch</strong>(<a href="http://api.dartlang.org/dart_core/String.html">String</a> branchName, <a href="../bot_git/PopulateTempDir.html">PopulateTempDir</a> populator, <a href="http://api.dartlang.org/dart_core/String.html">String</a> commitMessage) <a class="anchor-link" href="#populateBranch"
              title="Permalink to GitDir.populateBranch">#</a></h4>
<div class="doc">
<p>If the content provided matches the content in the specificed 
<span class="param">branchName</span>, then
<code>null</code> is returned.</p>
<p>If no content is added to the directory, an <code>Error</code> is thrown.</p>
<pre class="source">
Future&lt;Commit&gt; populateBranch(String branchName, PopulateTempDir populator, String commitMessage) {
 // TODO: ponder restricting branch names
 // see http://stackoverflow.com/questions/12093748/how-do-i-check-for-valid-git-branch-names/12093994#12093994

 requireArgumentNotNullOrEmpty(branchName, 'branchName');
 requireArgumentNotNullOrEmpty(commitMessage, 'commitMessage');

 _TempDirs tempDirs;

 return getBranchReference(branchName)
     .then((BranchReference value) {

       if(value == null) {
         return _getTempDirPairForNewBranch(branchName);
       } else {
         return _getTempDirPair(branchName);
       }
     })
     .then((_TempDirs value) {
       tempDirs = value;

       return populator(tempDirs.gitWorkTreeDir);
     })
     .then((_) {

       // make sure there is something in the working three
       return tempDirs.gitDir.runCommand(['ls-files', '--others']);
     })
     .then((ProcessResult pr) {
       if(pr.stdout.isEmpty) {
         throw 'No files were added';
       }
       // add new files to index

       // --verbose is not strictly needed, but nice for debugging
       return tempDirs.gitDir.runCommand(['add', '--all', '--verbose']);
     })
     .then((ProcessResult pr) {
       // now to see if we have any changes here
       return tempDirs.gitDir.runCommand(['status', '--porcelain']);
     })
     .then((ProcessResult pr) {
       if(pr.stdout.isEmpty) {
         // no change in files! we should return a null result
         return null;
       }

       // Time to commit.
       return tempDirs.gitDir.runCommand(['commit', '--verbose', '-m', commitMessage])
           .then((ProcessResult pr) {
             // --verbose is not strictly needed, but nice for debugging
             return tempDirs.gitDir.runCommand(['push', '--verbose', '--progress', path.toNativePath(), branchName]);
           })
           .then((ProcessResult pr) {
             // pr.stderr will have all of the info

             // so we have this wonderful new commit, right?
             // need to crack out the commit and return the value
             return getCommit('refs/heads/$branchName');
           });
     })
     .whenComplete(() {
       if(tempDirs != null) {
         return tempDirs.dispose();
       }
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="runCommand">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_io/ProcessResult.html">ProcessResult</a>&gt; <strong>runCommand</strong>(<a href="http://api.dartlang.org/dart_core/Iterable.html">Iterable</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; args, [<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> throwOnError = true]) <a class="anchor-link" href="#runCommand"
              title="Permalink to GitDir.runCommand">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;ProcessResult&gt; runCommand(Iterable&lt;String&gt; args, [bool throwOnError = true]) {
 requireArgumentNotNull(args, 'args');

 final list = args.toList();

 for(final arg in list) {
   requireArgumentNotNullOrEmpty(arg, 'args');
   requireArgument(!arg.contains(_workTreeArg), 'args', 'Cannot contain $_workTreeArg');
   requireArgument(!arg.contains(_gitDirArg), 'args', 'Cannot contain $_gitDirArg');
 }

 if(_gitWorkTree != null) {
   list.insert(0, '$_workTreeArg${_gitWorkTree.toNativePath()}');
 }

 return Git.runGit(list, throwOnError: throwOnError, processWorkingDir: _processWorkingDir);
}
</pre>
</div>
</div>
<div class="method"><h4 id="showRef">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="../bot_git/CommitReference.html">CommitReference</a>&gt;&gt; <strong>showRef</strong>({<a href="http://api.dartlang.org/dart_core/bool.html">bool</a> heads: false, <a href="http://api.dartlang.org/dart_core/bool.html">bool</a> tags: false}) <a class="anchor-link" href="#showRef"
              title="Permalink to GitDir.showRef">#</a></h4>
<div class="doc">
<pre class="source">
Future&lt;List&lt;CommitReference&gt;&gt; showRef({bool heads:false, bool tags:false}) {
 final args = ['show-ref'];

 if(heads) {
   args.add('--heads');
 }

 if(tags) {
   args.add('--tags');
 }

 return runCommand(args, false)
     .then((ProcessResult pr) {
       if(pr.exitCode == 1) {
         // no heads present, return empty collection
         return [];
       }

       // otherwise, it should have worked fine...
       assert(pr.exitCode == 0);

       return CommitReference.fromShowRefOutput(pr.stdout);
     });
}
</pre>
</div>
</div>
<div class="method"><h4 id="writeObjects">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/Map.html">Map</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>, <a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt;&gt; <strong>writeObjects</strong>(<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; paths) <a class="anchor-link" href="#writeObjects"
              title="Permalink to GitDir.writeObjects">#</a></h4>
<div class="doc">
<p>Given a list of 
<span class="param">paths</span>, write those files to the object store
and return a <code>Map</code> where the key is the input path and the value is
the SHA of the newly written object.</p>
<pre class="source">
Future&lt;Map&lt;String, String&gt;&gt; writeObjects(List&lt;String&gt; paths) {
 final args = ['hash-object', '-t', 'blob', '-w', '--no-filters', '--'];
 args.addAll(paths);
 return runCommand(args)
     .then((ProcessResult pr) {
       final val = pr.stdout.trim();
       final shas = val.split(new RegExp(r'\s+'));
       assert(shas.length == paths.length);
       assert(shas.every((sha) =&gt; _shaRegExp.hasMatch(sha)));
       final map = new Map&lt;String, String&gt;();
       for(var i = 0; i &lt; shas.length; i++) {
         map[paths[i]] = shas[i];
       }
       return map;
     });
}
</pre>
</div>
</div>
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="../client-live-nav.js"></script>
        </body></html>
        
