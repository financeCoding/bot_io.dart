        <!DOCTYPE html>
        <html>
        <head>
                <meta charset="utf-8">
        <title>bot_io Library / BOT Documentation</title>
        <link rel="stylesheet" type="text/css"
            href="styles.css">
        <link href="//fonts.googleapis.com/css?family=Open+Sans:400,600,700,800" rel="stylesheet" type="text/css">
        <link rel="shortcut icon" href="favicon.ico">
        
        </head>
        <body data-library="bot_io">
        <div class="page">
        <div class="header">
          <a href="index.html"><div class="logo"></div></a>
          <a href="index.html">BOT Documentation</a>
         &rsaquo; <a href="bot_io.html">bot_io</a>        <div id="search-box">
          <input type="search" name="q" id="q" autocomplete="off"
              class="search-input" placeholder="Search API">
        </div>
        
      </div>
      <div class="drop-down" id="drop-down"></div>
      
        <div class="nav">
        
</div>
<div class="content">
<h2><strong>bot_io</strong> library</h2>
<div>
<h3>Properties</h3>
<div class="field"><h4 id="COMPLETION_COMMAND_NAME">
<button class="show-code">Code</button>
const <a href="http://api.dartlang.org/dart_core/String.html">String</a>         <strong>COMPLETION_COMMAND_NAME</strong> <a class="anchor-link"
            href="#COMPLETION_COMMAND_NAME"
            title="Permalink to COMPLETION_COMMAND_NAME">#</a>
        </h4>
        <div class="doc">
<p>The string 'completion' used to denote that arguments proivded to an app are for command
completion.</p>
<p>The expected arg format is: completion -- {process name} {rest of current args}</p>
<pre class="source">
const String COMPLETION_COMMAND_NAME = 'completion'
</pre>
</div>
</div>
</div>
<div>
<h3>Functions</h3>
<div class="method"><h4 id="fileSha1Hex">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>fileSha1Hex</strong>(<a href="http://api.dartlang.org/dart_io/File.html">File</a> file) <a class="anchor-link" href="#fileSha1Hex"
              title="Permalink to fileSha1Hex">#</a></h4>
<div class="doc">
<p>Returns the 40-character hex SHA1 value of the provided file.</p>
<p>If 
<span class="param">file</span> is null or does not exist, errors will occur.</p>
<pre class="source">
Future&lt;String&gt; fileSha1Hex(File file) =&gt;
 _getFileSha1(file).then(crypto.CryptoUtils.bytesToHex);
</pre>
</div>
</div>
<div class="method"><h4 id="fileContentsMatch">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Future.html">Future</a>&lt;<a href="http://api.dartlang.org/dart_core/bool.html">bool</a>&gt; <strong>fileContentsMatch</strong>(<a href="http://api.dartlang.org/dart_io/File.html">File</a> file1, <a href="http://api.dartlang.org/dart_io/File.html">File</a> file2) <a class="anchor-link" href="#fileContentsMatch"
              title="Permalink to fileContentsMatch">#</a></h4>
<div class="doc">
<p>Returns a <code>Future</code> that evaluates to true if the contents of 
<span class="param">file1</span> and

<span class="param">file2</span> are the same.</p>
<p>Equality is determined by comparing the result of <a class="crossref" href="bot_io.html#fileSha1Hex">fileSha1Hex</a> for each
file.</p>
<pre class="source">
Future&lt;bool&gt; fileContentsMatch(File file1, File file2) {
 return Future.wait([fileSha1Hex(file1), fileSha1Hex(file2)])
     .then((List&lt;String&gt; shas) {
       assert(shas.length == 2);
       return shas[0] == shas[1];
 });
}
</pre>
</div>
</div>
<div class="method"><h4 id="expandStream">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> <strong>expandStream</strong>(<a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> source, <a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> convert(input), {<a href="http://api.dartlang.org/dart_async/Stream.html">Stream</a> onDone()}) <a class="anchor-link" href="#expandStream"
              title="Permalink to expandStream">#</a></h4>
<div class="doc">
<pre class="source">
Stream expandStream(Stream source, Stream convert(input), {Stream onDone()}) {
 final controller = new StreamController();

 Future itemFuture;

 source.listen((sourceItem) {
   Stream subStream = convert(sourceItem);
   Future next = _pipeStreamToController(controller, subStream);
   if(itemFuture == null) {
     itemFuture = next;
   } else {
     itemFuture = itemFuture.then((_) =&gt; next);
   }
 }, onDone: () {
   Future next = _pipeStreamToController(controller, onDone());
   if(itemFuture == null) {
     itemFuture = next;
   } else {
     itemFuture = itemFuture.then((_) =&gt; next);
   }
   itemFuture.whenComplete(() {
     controller.close();
   });
 });

 return controller.stream;
}
</pre>
</div>
</div>
<div class="method"><h4 id="getArgsCompletions">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; <strong>getArgsCompletions</strong>(<a href="args/ArgParser.html">ArgParser</a> parser, <a href="http://api.dartlang.org/dart_core/List.html">List</a>&lt;<a href="http://api.dartlang.org/dart_core/String.html">String</a>&gt; providedArgs, <a href="http://api.dartlang.org/dart_core/String.html">String</a> compLine, <a href="http://api.dartlang.org/dart_core/int.html">int</a> compPoint) <a class="anchor-link" href="#getArgsCompletions"
              title="Permalink to getArgsCompletions">#</a></h4>
<div class="doc">
<pre class="source">
List&lt;String&gt; getArgsCompletions(ArgParser parser, List&lt;String&gt; providedArgs,
   String compLine, int compPoint) {
 assert(parser != null);
 assert(providedArgs != null);
 // all arg entries: no empty items, no null items, all pre-trimmed
 for(int i = 0; i &lt; providedArgs.length; i++) {
   final arg = providedArgs[i];
   final msg = 'Arg at index $i with value "$arg" ';
   require(arg != null, msg + 'is null');
   require(arg.trim() == arg, msg + 'has whitespace');

   if(i &lt; (providedArgs.length-1)) {
     require(!arg.isEmpty, msg + 'Only the last arg can be an empty string');
   }
 }

 final sublog = (Object obj) {
   _log(obj, ['getArgsCompletions']);
 };

 sublog("provided args: ${_helpfulToString(providedArgs)}");
 sublog('COMP_LINE:  "$compLine"');
 sublog('COMP_POINT:  $compPoint');

 if(compPoint &lt; compLine.length) {
   // TODO: ponder smart ways to handle in-line completion
   sublog('cursor is in the middle of the line. NO-OP');
   return [];
 }

 if(providedArgs.isEmpty) {
   sublog('empty args. Complete with all available commands');
   return parser.commands.keys.toList();
 }

 final alignedArgsOptions = providedArgs
     .map((arg) =&gt; _getOptionForArg(parser, arg)).toList();

 /*
  * NOTE: nuanced behavior
  * If the last item provided is a full, real item (command or option)
  * It should be completed with its full name so the user can move on
  * Soooo....we are excluding the last item in [alignedArgsOptions] from
  * optionsDefinedInArgs
  *
  * Keep in mind, if we're already on to the next item to complete, the last item is likely
  * empty string '' or '--', so this isn't a problem
  */

 // a set of options in use (minus, potentially, the last one)
 // all non-null, all unique
 final optionsDefinedInArgs = alignedArgsOptions.take(alignedArgsOptions.length - 1)
     .where((o) =&gt; o != null)
     .toSet();
 sublog('defined options: ${optionsDefinedInArgs.map((o) =&gt; o.name).toSet()}');

 final parserOptionCompletions = $(_getParserOptionCompletions(parser, optionsDefinedInArgs))
     .toReadOnlyCollection();

 /*
  * KNOWN: at least one item in providedArgs last and first are now safe
  */

 /*
  * Now we're going to lean on the existing parse functionality to see
  * if the provided args (or a subset of them) parse to valid [ArgsResult]
  * If it does, we can use the result to determine what we should do next
  */

 final subsetTuple = _getValidSubset(parser, providedArgs);
 final validSubSet = subsetTuple.item1;
 final subsetResult = subsetTuple.item2;

 sublog('valid subset: ${_helpfulToString(validSubSet)}');

 /*
  * CASE: we have a command
  * get recursive
  */
 if(subsetResult != null &amp;&amp; subsetResult.command != null) {
   // get all of the args *after* the command name
   // call in recursively with the sub command parser, right?
   final subCommand = subsetResult.command;
   final subCommandIndex = providedArgs.indexOf(subCommand.name);
   assert(subCommandIndex &gt;= 0);
   sublog('so, it seems we have command "${subCommand.name}" at index $subCommandIndex');

   final subCommandParser = parser.commands[subCommand.name];
   final subCommandArgs = providedArgs.sublist(subCommandIndex + 1);

   /*
    * only start rockin' the sub command parser if
    * 1) there's a start on sub args
    * 2) there's whitespace at the end of compLine
    */

   if(!subCommandArgs.isEmpty || compLine.endsWith(' ')) {
     return getArgsCompletions(subCommandParser, subCommandArgs, compLine, compPoint);
   }
 }


 final removedItems = providedArgs.sublist(validSubSet.length);
 assert(removedItems.length + validSubSet.length == providedArgs.length);

 sublog('removed items: ${_helpfulToString(removedItems)}');

 final lastArg = providedArgs.last;

 /*
  * CASE: one removed item, that looks like a partial option
  * try to match it against available options
  */
 if(removedItems.length == 1 &amp;&amp;
     removedItems.single.startsWith('--')) {

   final removedItem = removedItems.single;

   if(compLine.endsWith(' ')) {
     // if the removed item maps to an option w/ allowed values
     // we should return those values to complete against
     final option = alignedArgsOptions[providedArgs.length-1];
     if(option != null &amp;&amp; option.allowed != null &amp;&amp; !option.allowed.isEmpty) {
       assert(!option.isFlag);

       sublog('completing all allowed value for option "${option.name}"');

       return option.allowed.toList();
     }


   } else {
     sublog('completing the name of options starting with "$removedItem"');

     return parserOptionCompletions
         .where((String option) =&gt; option.startsWith(removedItem))
         .toList();
   }
 }

 /*
  * CASE: second-to-last arg is an option+allowed and lastArg is empty
  * then we should complete with the available options, right?
  */
 if(providedArgs.length &gt;= 2) {
   final option = alignedArgsOptions[providedArgs.length - 2];
   if(option != null) {

     if(option.allowed != null &amp;&amp;
       !option.allowed.isEmpty) {

       assert(!option.isFlag);
       sublog('completing option "${option.name}"');

       final String optionValue = providedArgs[providedArgs.length-1];

       return option.allowed
           .where((String v) =&gt; v.startsWith(optionValue))
           .toList();
     } else if(!option.isFlag){
       sublog("not providing completions. Wating for option value");
       return [];
     }
   }
 }

 /*
  * CASE: no removed items and compLine ends in a space -&gt; do command completion
  */
 if(removedItems.isEmpty &amp;&amp; lastArg == '') {

   sublog('doing command completion');

   return parser.commands.keys.toList();
 }

 /*
  * CASE: If we have '--', then let's naively complete all options
  */
 if(lastArg == '--') {
   sublog('Completing with all available options.');
   return parserOptionCompletions.asList();
 }

 /*
  * CASE: a partial command name?
  * if the last arg doesn't start with a '-'
  */
 if(!lastArg.startsWith('-')) {
   // for now, let's pretend this is partial command

   sublog('completing command names that start with "$lastArg"');

   return parser.commands.keys
       .where((String commandName) =&gt; commandName.startsWith(lastArg))
       .toList();
 }

 /*
  * CASE: the last argument is valid, so we should return it
  * if types the last char of a valid option, hitting tab should complete it
  */
 if(lastArg != '' &amp;&amp; parserOptionCompletions.contains(lastArg)) {
   sublog('completing final arg');
   return [lastArg];
 }

 sublog("Exhausted options. No suggestions.");

 return [];
}
</pre>
</div>
</div>
<div class="method"><h4 id="tryArgsCompletion">
<button class="show-code">Code</button>
<a href="args/ArgResults.html">ArgResults</a> <strong>tryArgsCompletion</strong>(<a href="args/ArgParser.html">ArgParser</a> parser) <a class="anchor-link" href="#tryArgsCompletion"
              title="Permalink to tryArgsCompletion">#</a></h4>
<div class="doc">
<pre class="source">
ArgResults tryArgsCompletion(ArgParser parser) {
 final options = tryCompletion((List&lt;String&gt; args, String compLine, int compPoint) {
   return getArgsCompletions(parser, args, compLine, compPoint);
 });
 return parser.parse(options.arguments);
}
</pre>
</div>
</div>
<div class="method"><h4 id="tryCompletion">
<button class="show-code">Code</button>
<a href="http://api.dartlang.org/dart_io/Options.html">Options</a> <strong>tryCompletion</strong>(<a href="bot_io/ArgCompleter.html">ArgCompleter</a> completer) <a class="anchor-link" href="#tryCompletion"
              title="Permalink to tryCompletion">#</a></h4>
<div class="doc">
<pre class="source">
Options tryCompletion(ArgCompleter completer) {
 final options = new Options();
 final args = options.arguments;

 final scriptName = new Path(options.script).filename;
 if(scriptName.isEmpty) {
   // should have a script name...weird...
   return options;
 }

 _log('Checking for completion on script:\t$scriptName');
 if(args.length &gt;= 3 &amp;&amp;
     args[0] == COMPLETION_COMMAND_NAME &amp;&amp;
     args[1] == '--') {
   try {
     _log('Starting completion');
     _log('completion-reported exe: ${args[2]}');

     final env = Platform.environment;

     // There are 3 interesting env paramaters passed by the completion logic
     // COMP_LINE:  the full contents of the completion
     final compLine = env['COMP_LINE'];
     require(compLine != null, 'Environment variable COMP_LINE must be set');

     // COMP_CWORD: number of words. Also might be nice
     // COMP_POINT: where the cursor is on the completion line
     final compPointValue = env[_compPointVar];
     require(compPointValue != null &amp;&amp; !compPointValue.isEmpty,
         'Environment variable $_compPointVar must be set and non-empty');
     final compPoint = int.parse(compPointValue, onError: (val) {
       throw new FormatException('Could not parse $_compPointVar value "$val" into an integer');
     });

     final trimmedArgs = args.sublist(3);

     _log('input args:     ${_helpfulToString(trimmedArgs)}');

     final completions = completer(trimmedArgs, compLine, compPoint);

     _log('completions: ${_helpfulToString(completions)}');

     for(final comp in completions) {
       print(comp);
     }
     exit(0);
   } catch (ex, stack) {
     _log('An error occurred while attemping completion');
     _log(ex);
     _log(stack);
     exit(1);
   }
 }

 _log('Completion params not found');

 return options;
}
</pre>
</div>
</div>
<div class="method"><h4 id="enableScriptLogListener">
<button class="show-code">Code</button>
void <strong>enableScriptLogListener</strong>() <a class="anchor-link" href="#enableScriptLogListener"
              title="Permalink to enableScriptLogListener">#</a></h4>
<div class="doc">
<p>When called, a listener is added to the root <code>Logger</code> and all output is
appended to a log file named "<code>new Options().script</code>.log".</p>
<p>The format: <code>LogRecord.time</code> 'tab' <code>LogRecord.level</code> 'tab' <code>LogRecord.loggerName</code> 'tab' <code>LoggerRecord.message</code></p>
<pre class="source">
void enableScriptLogListener() {
 if(_scriptLogListenerPath == null) {
   final options = new Options();

   final script = options.script;
   _scriptLogListenerPath = new Path(script).toNativePath() + '.log';

   final rootLogger = logging.Logger.root;
   rootLogger.level = logging.Level.ALL;

   rootLogger.onRecord.listen(_doLog);

   final logger = logging.Logger.root;

   logger.info('Starting log for $script at $_scriptLogListenerPath');
 }
}
</pre>
</div>
</div>
</div>
<div>
<h3>Abstract Classes</h3>
          <div class="type">
          <h4>
            <a href="bot_io/DirectoryPopulater.html"><strong>DirectoryPopulater</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/EntityValidator.html"><strong>EntityValidator</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/ShellString.html"><strong>ShellString</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Classes</h3>
          <div class="type">
          <h4>
            <a href="bot_io/AnsiColor.html"><strong>AnsiColor</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/ColumnDefinition.html"><strong>ColumnDefinition</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/Console.html"><strong>Console</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/EntityExistsValidator.html"><strong>EntityExistsValidator</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/IoHelpers.html"><strong>IoHelpers</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/MapDirectoryPopulater.html"><strong>MapDirectoryPopulater</strong></a>
          </h4>
          </div>
          
          <div class="type">
          <h4>
            <a href="bot_io/TempDir.html"><strong>TempDir</strong></a>
          </h4>
          </div>
          
</div>
<div>
<h3>Typedefs</h3>
          <div class="type">
          <h4>
            <a href="bot_io/ArgCompleter.html"><strong>ArgCompleter</strong></a>
          </h4>
          </div>
          
</div>
        </div>
        <div class="clear"></div>
        </div>
        <div class="footer">
          
        </div>
        <script async src="client-live-nav.js"></script>
        </body></html>
        
